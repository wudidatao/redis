故障判定阶段
1.持续判断每个slave最后一次完成repl-ping-slave-period成功到达master
2.当达到cluster-node-timeout前，如果repl-ping-slave-period成功，则继续1的判断
2.当达到cluster-node-timeout后，如果repl-ping-slave-period依旧没有成功，则集群slave节点认为master故障，开始进入仲裁阶段

仲裁阶段
1.进入仲裁阶段后，集群先查看所有slave节点的slave-priority，优先使用值最小的节点作为新的master
2.当slave成为新的master，旧的master即使再重新加入集群，也会被降级为slave

内存耗尽
1.当redis使用的内存达到maxmemory，redis会根据maxmemory-policy设置的策略清除内存中的key，来为新key腾出空间
2.如果不能清除内存中的key，或者maxmemory-policy设置为noeviction，客户端会返回一个错误，然后继续申请更多的内存，并只能响应GET之类的命令
3.如果可以清除内存中的key，redis将根据maxmemory-policy配置的算法，清除部分或者全部满足条件的过期key，来为新key腾出空间
4.maxmemory-policy的精确度将由maxmemory-samples决定，设置越大越精确

LRU过期数据清理
1.主动清理，redis提供了serverCron方法来周期性的清理过期数据（serverCron每间隔1000/hz ms会调用databasesCron方法来检测并淘汰过期的key）
2.被动清理，每次写入key时，发现内存不够，调用activeExpireCycle释放一部分内存，每次访问相关的key，如果发现key过期，直接释放掉该key相关的内存

redis做为缓存，经常采用LRU的策略来淘汰数据，所以如果同时过期的数据太多，就会导致redis发起主动检测时耗费的时间过长(最大为250ms)，从而导致最大应用超时 >= 250ms。

timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100   
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC=25  
server.hz>=1(默认为10)  
timelimit <= 250ms 

内存使用率过高，则会导致内存不够，从而发起被动淘汰策略，从而使应用访问超时，合理的调整hz参数，从而控制每次主动淘汰的频率，从而有效的缓解过期的key数量太多带来的上述超时问题题

Redis的数据回写机制分同步和异步两种
同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的
异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死一般默认会采用这个方法。
默认采用方式2，所以如果我们要将数据刷到硬盘上，这时redis分配内存不能太大，否则很容易发生内存不够用无法fork的问题
