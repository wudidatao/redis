故障判定阶段
1.持续判断每个slave最后一次完成repl-ping-slave-period成功到达master
2.当达到cluster-node-timeout前，如果repl-ping-slave-period成功，则继续1的判断
2.当达到cluster-node-timeout后，如果repl-ping-slave-period依旧没有成功，则集群slave节点认为master故障，开始进入仲裁阶段

仲裁阶段
1.进入仲裁阶段后，集群先查看所有slave节点的slave-priority，优先使用值最小的节点作为新的master
2.当slave成为新的master，旧的master即使再重新加入集群，也会被降级为slave

内存耗尽
1.当redis使用的内存达到maxmemory，redis会根据maxmemory-policy设置的策略清除内存中的key，来为新key腾出空间
2.如果不能清除内存中的key，或者maxmemory-policy设置为noeviction，客户端会返回一个错误，然后继续申请更多的内存，并只能响应GET之类的命令
3.如果可以清除内存中的key，redis将根据maxmemory-policy配置的算法，清除部分或者全部满足条件的过期key，来为新key腾出空间
4.maxmemory-policy的精确度将由maxmemory-samples决定，设置越大越精确

LRU过期数据清理
1.主动清理，redis提供了serverCron方法来周期性的清理过期数据（serverCron每间隔1000/hz ms会调用databasesCron方法来检测并淘汰过期的key）
2.被动清理，每次写入key时，发现内存不够，调用activeExpireCycle释放一部分内存，每次访问相关的key，如果发现key过期，直接释放掉该key相关的内存

redis做为缓存，经常采用LRU的策略来淘汰数据，所以如果同时过期的数据太多，就会导致redis发起主动检测时耗费的时间过长(最大为250ms)，从而导致最大应用超时 >= 250ms。

timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100   
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC=25  
server.hz>=1(默认为10)  
timelimit <= 250ms 

内存使用率过高，则会导致内存不够，从而发起被动淘汰策略，从而使应用访问超时，合理的调整hz参数，从而控制每次主动淘汰的频率，从而有效的缓解过期的key数量太多带来的上述超时问题题

Redis的数据回写机制分同步和异步两种
1.同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的
当执行SAVE命令时，Redis同步进行快照操作，期间会阻塞所有来自客户端的请求，所以放数据库数据较多时，应该避免使用该命令
2.异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死一般默认会采用这个方法
从命令名字就能看出来，这个命令与SAVE命令的区别就在于该命令的快照操作是在后台异步进行的，进行快照操作的同时还能处理来自客户端的请求
执行BGSAVE命令后Redis会马上返回OK表示开始进行快照操作，如果想知道快照操作是否已经完成，可以使用LASTSAVE命令返回最近一次成功执行快照的时间，返回结果是一个Unix时间戳

快照执行的过程如下：
（1）Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）
（2）父进程继续处理来自客户端的请求，子进程开始将内存中的数据写入硬盘中的临时文件
（3）当子进程写完所有的数据后，用该临时文件替换旧的RDB文件，至此，一次快照操作完成
在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻，
父进程和子进程共享同一块内存数据，当父进程需要修改其中的某片数据（如执行写命令）时，
操作系统会将该片数据复制一份以保证子进程不受影响，所以RDB文件存储的是执行fork操作那一刻的内存数据。
所以RDB方式理论上是会存在丢数据的情况的(fork之后修改的的那些没有写进RDB文件)

AOF
在使用Redis存储非临时数据时，一般都需要打开AOF持久化来降低进程终止导致的数据丢失，AOF可以将Redis执行的每一条写命令追加到硬盘文件中，
这一过程显然会降低Redis的性能，但是大部分情况下这个影响是可以接受的，另外，使用较快的硬盘能提高AOF的性能。

AOF文件重写
AOF文件是可识别的纯文本，它的内容就是一个个的Redis标准命令,
AOF日志也不是完全按客户端的请求来生成日志的，比如命令 INCRBYFLOAT 在记AOF日志时就被记成一条SET记录，因为浮点数操作可能在不同的系统上会不同，所以为了避免同一份日志在不同的系统上生成不同的数据集，所以这里只将操作后的结果通过SET来记录。
每一条写命令都生成一条日志，AOF文件会很大。
AOF重写是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。
其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。
在写入新文件的过程中，所有的写操作日志还是会写到原来老的AOF文件中，同时还会记录在内存缓冲区中。
当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的AOF文件取代老的AOF文件。
命令：BGREWRITEAOF， 我们应该经常调用这个命令来来重写。
AOF重写的时机根据auto-aof-rewrite-percentage和auto-aof-rewrite-min-size决定
