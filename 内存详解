http://www.cnblogs.com/susufufu/p/7875210.html

2.Redis主进程的内存消耗：
Redis自身使用的内存：消耗很少，3MB多点
对象内存
缓冲内存
内存碎片
2.1对象内存：所有key对象长度 + 所有value对象长度
每次创建键值对时，至少创建两个类型对象：key对象、value对象，应该使用短键名
2.2缓冲内存：
每个客户端的输入、输出缓冲内存：
输入缓冲最大1G，超出则关闭该客户端连接；
输出缓冲：16KB的固定缓冲区、动态缓冲区，动态缓冲区可通过client-output-buffer-limit配置参数限制（根据客户端类型normal、slave、pubsub，分开设置）
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60 //超过256MB时，或者持续超过64MB达60秒，关闭连接
client-output-buffer-limit pubsub 32mb 8mb 60
复制积压缓冲内存：用于主从复制的部分复制，所有客户端共享该缓冲区，默认1MB，可通过repl-backlog-size调整，适当调大，可有效避免全量复制；
AOF缓冲内存：用于保存在AOF重写期间的写命令，便于重写完毕后把缓冲的命令追加到AOF文件中；
2.3内存碎片：
当存储的数据长短差异较大时，就容易出现大量内存碎片，应该尽可能地保持数据对齐或使用固定长度的字符串；
内存碎片只能通过完全重启Redis来清除；
3.Redis子进程内存消耗：
在执行AOF重写和RDB快照持久化时，会fork一个子进程，父子进程将共享此刻的内存快照，期间，在Linux下使用写时复制技术：父进程会为新进的写命令请求需要修改的内存页复制出一份副本来完成写操作，子进程结束后，父进程再把该副本覆盖回原来的内存页。
Linux默认开启的THP把写时复制期间的内存页复制单位从4KB变为2MB，加大了持久化时的内存消耗，应该关闭该功能：sudo echo never > /sys/kernel/mm/transparent_hugepage/enabled
4.内存管理：
设置内存上限，并指定内存回收策略；
maxmemory配置参数可限制当前Redis实例可使用的最大内存；
通过config set maxmemory可根据业务需求，动态调整内存限制；
通过设置内存上限，可方便地在一台服务器上部署多个Redis实例
4.1内存回收策略：
为键设置过期属性，Redis采用惰性删除和定时任务删除机制实现过期键的内存回收；
惰性删除：在读取键时才检查是否过期
定时任务删除：通过hz配置参数设置频率，默认每秒10次；
内存溢出控制策略：共6中策略，通过maxmemory-policy配置参数控制，默认noeviction（不删除，拒绝写入，返回错误）
LRU算法表示最近最少使用的，LFU算法表示最不常用的：
＃volatile-lru - >在设置了过期的key中，删除最近最少使用的key，直到空间足够为止
＃allkeys-lru - >从所有key里删除最近最少使用的key，不管有没设置过期，直到空间足够为止
＃volatile-lfu - >在设置了过期的key中，删除最少使用的key，直到空间足够为止
＃allkeys-lfu - >从所有key里删除最少使用的key，不管有没设置过期，直到空间足够为止
＃volatile-random - >删除一个过期集合中的随机key。
＃allkeys-random - >删除一个随机key，不管有没设置过期。
＃volatile-ttl - >删除即将过期的key（次TTL）
＃noviction - >不删除，拒绝写入，写入操作时返回错误。
maxmemory-samples 5 是说每次进行淘汰的时候，会随机抽取5个key 从里面淘汰最少使用的（默认选项）
应避免内存溢出，因为在内存溢出且非noeviction策略时，会频繁触发回收内存的操作，影响Redis性能，若有从节点，还会把删除命令同步给从节点；
对于只做缓存的场景下，可通过调小maxmemory，并执行一次命令，如果使用非noeviction策略，则会一次性回收到maxmemory指定的内存使用量，实现内存的快速回收，但会导致数据丢失和短暂阻塞；
5.内存优化：
Redis存储的所有数据都使用redisObject来封装，包括string、hash、list、set、zset
redisObject的字段：
type字段：保存对象使用的数据类型，命令type {key}返回值对象的数据类型
encoding字段：保存对象使用的内部编码类型，命令object encoding {key}返回值对象的内部编码类型
lru字段：记录对象最后一次被访问的时间（用于内存回收），命令object idletime {key}查看键的空闲时间（可配合scan命令批量查找长期空闲的键进行清理）
refcount字段：记录对象的引用计数（用于回收），命令object refcount {key}查看键的引用数
*ptr字段：存储值对象的数据或指针，如果是整数，则直接存储数据，否则表示指向数据的指针
字符串长度在39字节以内对象，在创建redisObject封装对象时只需分配内存1次，可提高性能；
缩减键、值对象的长度：简化键名，使用高效的序列化工具来序列化值对象，还可使用压缩工具(Google Snappy)压缩序列化后的数据；
共享对象池：Redis内部维护[0-9999]的整数对象池，对于0-9999的内部整数类型的元素、整数值对象都会直接引用整数对象池中的对象，因此尽量使用整数对象可节省内存；
注意：
启用LRU相关的溢出策略时，无法使用共享对象池；
对于ziplist编码的值对象，也无法使用共享对象池（成本过高）；
Redis对字符串的优化：
Redis所有key都是string类型，且value对象的数据除了整数之外，最终也都使用string来存储；
Redis字符串结构采用SDS(内部简单动态字符串)：
int len字段：已用字节长度
int free字段：未用字节长度
char buf[]字段：字节数组
SDS字符串特点：
获取字符串长度、未用长度速度快，时间复杂度为O(1)
用字节数组保存数据，支持安全的二进制数据存储
内部实现了预分配内存机制，降低内存分配次数
惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留
SDS字符串内存预分配机制：
首次创建时，不做预分配，数据刚好填满字节数组，len字段为字节数组长度，free字段为0
在修改字符后，如果原本的free空间不足，且当前总数据大小<1MB，则每次预分配1倍容量，而如果总数据大小>1MB，则每次预分配1MB容量。
如：（忽略len、free字段所占内存，只考虑buf所占内存）
对于首次创建的30字节字符串，对它执行append追加10字节，将使用(30+10)+40+1=81字节的内存
而直接set这40字节的字符串，只使用41字节的内存（1字节为结尾标识'\0'）
应该尽量避免频繁执行增长字符串的命令，如append、setrange，改为直接用set一次性创建字符串，减少预分配带来的内存浪费和降低内存碎片率；
字符串重构：（编码为ziplist的hash数据结构的妙用1）
对于非简单字符串数据，可用hash数据结构代替
因为小hash使用ziplist编码，可节省内存（字符串数据必须小于hash-max-ziplit-value配置的值）
且hash可用使用hmget、hmset命令，支持field-value的部分读取修改，而不必每次都整体存取 
